package bundlecore

import (
	"bytes"
	"context"
	"crypto/ecdsa"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"math"
	"math/big"
	"net/http"
	"strings"
	"sync"
	"time"

	"github.com/ethereum/go-ethereum"
	"github.com/ethereum/go-ethereum/accounts/abi/bind"
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	gethcrypto "github.com/ethereum/go-ethereum/crypto"
	"github.com/ethereum/go-ethereum/ethclient"

	"github.com/lmittmann/flashbots"
	w3 "github.com/lmittmann/w3"
)

type Params struct {
	RPC         string
	ChainID     *big.Int
	Relays      []string
	AuthPrivHex string
	Logf        func(string, ...any)
	OnSimResult func(relay, raw string, ok bool, err string)

	Token     common.Address
	From      common.Address
	To        common.Address
	AmountWei *big.Int

	SafePKHex string
	FromPKHex string

	Blocks       int
	TipGweiBase  int64
	TipMul       float64
	BaseMul      int64
	BufferPct    int64
	SimulateOnly bool
	SkipIfPaused bool
}

type Result struct {
	Included bool
	Reason   string
}

func (p *Params) logf(format string, a ...any) { if p.Logf != nil { p.Logf(format, a...) } }

func hexToECDSAPriv(s string) (*ecdsa.PrivateKey, error) {
	h := strings.TrimSpace(strings.TrimPrefix(s, "0x"))
	if len(h) == 0 { return nil, errors.New("empty private key") }
	return gethcrypto.HexToECDSA(h)
}
func gweiToWei(g int64) *big.Int { x:= new(big.Int).SetInt64(g); return x.Mul(x, big.NewInt(1_000_000_000)) }
func mulBig(a *big.Int, m int64) *big.Int { if a==nil { return big.NewInt(0) }; return new(big.Int).Mul(a, big.NewInt(m)) }
func addBig(a, b *big.Int) *big.Int { if a==nil { return b }; if b==nil { return a }; return new(big.Int).Add(a, b) }

func encodeERC20Transfer(to common.Address, amount *big.Int) []byte {
	selector := common.FromHex("0xa9059cbb")
	arg1 := common.LeftPadBytes(to.Bytes(), 32)
	arg2 := common.LeftPadBytes(amount.Bytes(), 32)
	return append(selector, append(arg1, arg2...)...)
}

var pausedSigs = [][]byte{
	common.FromHex("0x5c975abb"), // paused()
	common.FromHex("0x3f4ba83a"), // isPaused()
	common.FromHex("0x51dff989"), // transfersPaused()
	common.FromHex("0x5c701d2f"), // tradingPaused()
	common.FromHex("0x8462151c"), // isTradingPaused()
	common.FromHex("0x2e1a7d4d"), // pausedTransfers()
	common.FromHex("0x0b3bafd6"), // globalPaused()
	common.FromHex("0x9c6a3b7c"), // transferEnabled()
	common.FromHex("0x75f12b21"), // isTransferEnabled()
	common.FromHex("0x4f2be91f"), // tradingEnabled()
	common.FromHex("0x0dfe1681"), // isTradingEnabled()
}

func checkPaused(ctx context.Context, ec *ethclient.Client, token common.Address) (known, paused bool, err error) {
	for _, sig := range pausedSigs {
		res, e := ec.CallContract(ctx, ethereum.CallMsg{To:&token, Data:sig}, nil)
		if e != nil || len(res) == 0 { continue }
		b := res[len(res)-1]
		s := hex.EncodeToString(sig)
		if strings.Contains(s, "enabled") {
			return true, b == 0, nil
		}
		return true, b == 1, nil
	}
	return false, false, nil
}

func estimateTransferGas(ctx context.Context, ec *ethclient.Client, from common.Address, token common.Address, data []byte) (uint64, error) {
	msg := ethereum.CallMsg{ From: from, To:&token, Value:big.NewInt(0), Data:data }
	return ec.EstimateGas(ctx, msg)
}

func latestBaseFee(ctx context.Context, ec *ethclient.Client) (*big.Int, *big.Int, error) {
	h, err := ec.HeaderByNumber(ctx, nil)
	if err != nil { return nil, nil, err }
	if h.BaseFee == nil { return nil, h.Number, errors.New("no baseFee (pre-1559?)") }
	return new(big.Int).Set(h.BaseFee), new(big.Int).Set(h.Number), nil
}

func txAsHex(tx *types.Transaction) string { b,_ := tx.MarshalBinary(); return "0x" + hex.EncodeToString(b) }

func buildDynamicTx(chain *big.Int, nonce uint64, to *common.Address, value *big.Int, gasLimit uint64, tip, feeCap *big.Int, data []byte) *types.Transaction {
	df := &types.DynamicFeeTx{
		ChainID: chain, Nonce: nonce, Gas: gasLimit, GasTipCap: new(big.Int).Set(tip), GasFeeCap: new(big.Int).Set(feeCap),
		To: to, Value: new(big.Int).Set(value), Data: data,
	}
	return types.NewTx(df)
}

func signTx(tx *types.Transaction, chain *big.Int, prv *ecdsa.PrivateKey) (*types.Transaction, error) {
	signer := types.LatestSignerForChainID(chain)
	return types.SignTx(tx, signer, prv)
}

type rpcReq struct {
	Jsonrpc string      `json:"jsonrpc"`
	Method  string      `json:"method"`
	Params  interface{} `json:"params"`
	ID      int         `json:"id"`
}
type rpcResp struct {
	Jsonrpc string          `json:"jsonrpc"`
	ID      int             `json:"id"`
	Result  json.RawMessage `json:"result,omitempty"`
	Error   *struct {
		Code    int    `json:"code"`
		Message string `json:"message"`
		Data    any    `json:"data,omitempty"`
	} `json:"error,omitempty"`
}

func sendMevBundle(ctx context.Context, url string, authPriv *ecdsa.PrivateKey, txHexes []string, targetBlock *big.Int) (string, error) {
	payload := map[string]any{
		"txs": txHexes,
		"blockNumber": fmt.Sprintf("0x%x", targetBlock),
	}
	params := []any{ payload }
	body, _ := json.Marshal(rpcReq{ Jsonrpc:"2.0", Method:"mev_sendBundle", Params: params, ID:1 })

	req, _ := http.NewRequestWithContext(ctx, "POST", url, bytes.NewReader(body))
	req.Header.Set("Content-Type", "application/json")
	if authPriv != nil {
		addr := gethcrypto.PubkeyToAddress(authPriv.PublicKey)
		sig := gethcrypto.Keccak256Hash(body).Hex()
		req.Header.Set("X-Flashbots-Signature", addr.Hex()+":"+sig)
	}

	resp, err := http.DefaultClient.Do(req)
	if err != nil { return "", err }
	defer resp.Body.Close()
	var out rpcResp
	if err := json.NewDecoder(resp.Body).Decode(&out); err != nil { return "", err }
	if out.Error != nil { return "", errors.New(out.Error.Message) }
	return string(out.Result), nil
}

func Run(ctx context.Context, ec *ethclient.Client, p Params) (Result, error) {
	if p.AmountWei == nil || p.AmountWei.Sign() <= 0 { return Result{}, errors.New("AmountWei must be > 0") }
	if p.ChainID == nil {
		chainID, err := ec.ChainID(ctx); if err != nil { return Result{}, fmt.Errorf("chain id: %w", err) }
		p.ChainID = chainID
	}
	safePrv, err := hexToECDSAPriv(p.SafePKHex); if err != nil { return Result{}, fmt.Errorf("safe pk: %w", err) }
	fromPrv, err := hexToECDSAPriv(p.FromPKHex); if err != nil { return Result{}, fmt.Errorf("from pk: %w", err) }
	authPrv, err := hexToECDSAPriv(p.AuthPrivHex); if err != nil { return Result{}, fmt.Errorf("auth pk: %w", err) }

	if p.SkipIfPaused {
		if known, paused, _ := checkPaused(ctx, ec, p.Token); known && paused {
			p.logf("[pre-check] token is paused => skip")
			return Result{Included:false, Reason:"token paused"}, nil
		}
	}

	var classic []*w3.Client
	var matchmakers []string
	for _, r := range p.Relays {
		u := strings.TrimSpace(r); if u=="" { continue }
		if strings.Contains(strings.ToLower(u), "mev") || strings.Contains(strings.ToLower(u), "matchmaker") {
			matchmakers = append(matchmakers, u)
		} else {
			classic = append(classic, flashbots.MustDial(u, authPrv))
		}
	}
	if len(classic) == 0 && len(matchmakers) == 0 {
		return Result{}, errors.New("no relays or matchmakers configured")
	}

	calldata := encodeERC20Transfer(p.To, p.AmountWei)

	if p.Blocks <= 0 { p.Blocks = 6 }
	if p.TipGweiBase <= 0 { p.TipGweiBase = 3 }
	if p.TipMul <= 0 { p.TipMul = 1.2 }
	if p.BaseMul <= 0 { p.BaseMul = 2 }
	if p.BufferPct < 0 { p.BufferPct = 0 }

	startFromNonce, err := ec.PendingNonceAt(ctx, p.From); if err != nil { return Result{}, fmt.Errorf("nonce(from): %w", err) }

	for attempt := 0; attempt < p.Blocks; attempt++ {
		baseFee, headNum, err := latestBaseFee(ctx, ec); if err != nil { return Result{}, fmt.Errorf("basefee: %w", err) }
		targetBlock := new(big.Int).Add(headNum, big.NewInt(1+int64(attempt)))

		curFromNonce, _ := ec.PendingNonceAt(ctx, p.From)
		if curFromNonce > startFromNonce {
			p.logf("[abort] competing nonce detected (start=%d now=%d)", startFromNonce, curFromNonce)
			return Result{Included:false, Reason:"competing nonce"}, nil
		}

		tip := gweiToWei(int64(math.Round(float64(p.TipGweiBase) * math.Pow(p.TipMul, float64(attempt)))))
		maxFee := addBig(mulBig(baseFee, p.BaseMul), tip)

		gasLimit, err := estimateTransferGas(ctx, ec, p.From, p.Token, calldata)
		if err != nil { gasLimit = 90_000; p.logf("[warn] estimateGas failed: %v => fallback gas=%d", err, gasLimit) }
		feePerGas := new(big.Int).Add(baseFee, tip)
		cost := new(big.Int).Mul(feePerGas, new(big.Int).SetUint64(gasLimit))
		if p.BufferPct > 0 {
			buf := new(big.Int).Mul(cost, big.NewInt(p.BufferPct)); buf.Div(buf, big.NewInt(100)); cost.Add(cost, buf)
		}

		safeNonce, err := ec.PendingNonceAt(ctx, gethcrypto.PubkeyToAddress(safePrv.PublicKey)); if err != nil { return Result{}, fmt.Errorf("nonce(safe): %w", err) }
		fromNonce, err := ec.PendingNonceAt(ctx, p.From); if err != nil { return Result{}, fmt.Errorf("nonce(from): %w", err) }

		to1 := p.From
		tx1 := buildDynamicTx(p.ChainID, safeNonce, &to1, cost, 21_000, tip, maxFee, nil)
		signed1, err := signTx(tx1, p.ChainID, safePrv); if err != nil { return Result{}, fmt.Errorf("sign safe: %w", err) }

		to2 := p.Token
		tx2 := buildDynamicTx(p.ChainID, fromNonce, &to2, big.NewInt(0), gasLimit, tip, maxFee, calldata)
		signed2, err := signTx(tx2, p.ChainID, fromPrv); if err != nil { return Result{}, fmt.Errorf("sign from: %w", err) }

		p.logf("[attempt %d/%d] block=%s gas=%d tip=%s feeCap=%s cost=%s nonce(safe=%d, from=%d)",
			attempt+1, p.Blocks, targetBlock.String(), gasLimit, tip.String(), maxFee.String(), cost.String(), safeNonce, fromNonce)
		p.logf("  tx1(safe->from): %s", txAsHex(signed1))
		p.logf("  tx2(transfer) : %s", txAsHex(signed2))

		var simOK bool
		var wgSim sync.WaitGroup
		for _, rc := range classic {
			rc := rc; wgSim.Add(1)
			go func(){
				defer wgSim.Done()
				var resp *flashbots.CallBundleResponse
				err2 := rc.Call(
					flashbots.CallBundle(&flashbots.CallBundleRequest{
						Transactions: types.Transactions{signed1, signed2},
						BlockNumber:  new(big.Int).Set(targetBlock),
					}).Returns(&resp),
				)
				ok := (err2 == nil)
				raw := ""; errStr := ""
				if resp != nil {
					b,_ := json.Marshal(resp); raw = string(b)
					for _, r := range resp.Results {
						if r.Error != nil || len(r.Revert)>0 {
							ok = false
							if r.Error != nil { errStr = r.Error.Error() } else { errStr = r.Revert }
							break
						}
					}
				}
				if !ok && err2 != nil { errStr = err2.Error() }
				if p.OnSimResult != nil { p.OnSimResult(rc.URL(), raw, ok, errStr) }
				if ok { simOK = true }
			}()
		}
		for _, u := range matchmakers {
			if p.OnSimResult != nil { p.OnSimResult(u, "", false, "simulation not supported on matchmaker") }
		}
		wgSim.Wait()

		if !simOK {
			p.logf("[attempt %d] simulation failed on all classic relays â€” retry", attempt+1)
			curFromNonce2, _ := ec.NonceAt(ctx, p.From, nil)
			if curFromNonce2 > startFromNonce { return Result{Included:false, Reason:"competing nonce"}, nil }
			continue
		}
		if p.SimulateOnly { return Result{Included:false, Reason:"simulate only"}, nil }

		raw1, raw2 := txAsHex(signed1), txAsHex(signed2)
		txHexes := []string{raw1, raw2}
		var wgSend sync.WaitGroup
		for _, rc := range classic {
			rc := rc; wgSend.Add(1)
			go func(){
				defer wgSend.Done()
				var bundleHash common.Hash
				err3 := rc.Call(
					flashbots.SendBundle(&flashbots.SendBundleRequest{
						Transactions: types.Transactions{signed1, signed2},
						BlockNumber:  new(big.Int).Set(targetBlock),
					}).Returns(&bundleHash),
				)
				if err3 != nil { p.logf("[send %s] err: %v", rc.URL(), err3); return }
				p.logf("[send %s] bundle submitted: %s", rc.URL(), bundleHash.Hex())
			}()
		}
		for _, u := range matchmakers {
			u := u; wgSend.Add(1)
			go func(){
				defer wgSend.Done()
				res, err3 := sendMevBundle(ctx, u, authPrv, txHexes, targetBlock)
				if err3 != nil { p.logf("[mev_sendBundle %s] err: %v", u, err3); return }
				p.logf("[mev_sendBundle %s] ok: %s", u, res)
			}()
		}
		wgSend.Wait()

		waitCtx, cancel := context.WithTimeout(ctx, 25*time.Second); defer cancel()
		incl, reason, err := waitInclusionOrCompete(waitCtx, ec, p.From, startFromNonce, signed2.Hash(), targetBlock)
		if err != nil { p.logf("[attempt %d] wait err: %v", attempt+1, err) }
		if incl { return Result{Included:true, Reason:reason}, nil }
		if reason == "competing nonce" { return Result{Included:false, Reason:reason}, nil }
	}

	return Result{Included:false, Reason:"exhausted attempts"}, nil
}

func waitInclusionOrCompete(ctx context.Context, ec *ethclient.Client, from common.Address, startNonce uint64, ourTx2 common.Hash, targetBlock *big.Int) (bool, string, error) {
	for {
		select {
		case <-ctx.Done():
			return false, "timeout waiting block", ctx.Err()
		default:
			h, err := ec.HeaderByNumber(ctx, targetBlock)
			if err == nil && h != nil && h.Number != nil && h.Number.Cmp(targetBlock) == 0 { goto CHECK }
			time.Sleep(500 * time.Millisecond)
		}
	}
CHECK:
	latestNonce, err := ec.NonceAt(ctx, from, nil)
	if err == nil && latestNonce > startNonce {
		rcpt, err2 := ec.TransactionReceipt(ctx, ourTx2)
		if err2 == nil && rcpt != nil && rcpt.BlockNumber != nil && rcpt.BlockNumber.Cmp(targetBlock) == 0 && rcpt.Status == types.ReceiptStatusSuccessful {
			return true, "included", nil
		}
		return false, "competing nonce", nil
	}
	rcpt, err := ec.TransactionReceipt(ctx, ourTx2)
	if err == nil && rcpt != nil && rcpt.BlockNumber != nil && rcpt.BlockNumber.Cmp(targetBlock) == 0 && rcpt.Status == types.ReceiptStatusSuccessful {
		return true, "included", nil
	}
	return false, "not included", nil
}

func NewTransactorFromHex(pkHex string, chainID *big.Int) (*bind.TransactOpts, error) {
	prv, err := gethcrypto.HexToECDSA(strings.TrimPrefix(pkHex,"0x"))
	if err != nil { return nil, err }
	return bind.NewKeyedTransactorWithChainID(prv, chainID)
}
